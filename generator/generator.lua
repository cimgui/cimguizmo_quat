--------------------------------------------------------------------------
--script for auto_funcs.h and auto_funcs.cpp generation
--expects LuaJIT
--------------------------------------------------------------------------
assert(_VERSION=='Lua 5.1',"Must use LuaJIT")
assert(bit,"Must use LuaJIT")
local script_args = {...}
local COMPILER = script_args[1]
--COMPILER = "gcc"
local CPRE,CTEST
if COMPILER == "gcc" or COMPILER == "clang" then
    CPRE = COMPILER..[[ -E -DIMGUI_DISABLE_OBSOLETE_FUNCTIONS -DIMGUI_API="" -DIMGUI_IMPL_API="" ]]
    CTEST = COMPILER.." --version"
elseif COMPILER == "cl" then
    CPRE = COMPILER..[[ /E /DIMGUI_DISABLE_OBSOLETE_FUNCTIONS /DIMGUI_API="" /DIMGUI_IMPL_API="" ]]
    CTEST = COMPILER
else
    print("Working without compiler ")
	error("cant work with "..COMPILER.." compiler")
end
--test compiler present
local HAVE_COMPILER = false

local pipe,err = io.popen(CTEST,"r")
if pipe then
    local str = pipe:read"*a"
    print(str)
    pipe:close()
    if str=="" then
        HAVE_COMPILER = false
    else
        HAVE_COMPILER = true
    end
else
    HAVE_COMPILER = false
    print(err)
end
assert(HAVE_COMPILER,"gcc, clang or cl needed to run script")


print("HAVE_COMPILER",HAVE_COMPILER)

--------------------------------------------------------------------------
--this table has the functions to be skipped in generation
--------------------------------------------------------------------------
local cimgui_manuals = {
    -- igLogText = true,
    -- ImGuiTextBuffer_appendf = true,
}
--------------------------------------------------------------------------
--this table is a dictionary to force a naming of function overloading (instead of algorythmic generated)
--first level is cimguiname without postfix, second level is the signature of the function, value is the
--desired name
---------------------------------------------------------------------------
local cimgui_overloads = {
    --igPushID = {
        --["(const char*)"] =           "igPushIDStr",
        --["(const char*,const char*)"] = "igPushIDRange",
        --["(const void*)"] =           "igPushIDPtr",
        --["(int)"] =                   "igPushIDInt"
    --},
}

--------------------------header definitions
local cimgui_header = 
[[//This file is automatically generated by generator.lua from https://github.com/cimgui/cimguizmo_quat
//based on imGuIZMOquat.h file version  XXX from https://github.com/BrutPitt/imGuIZMO.quat
]]
--------------------------------------------------------------------------
--helper functions
--------------------------------functions for C generation
--load parser module
package.path = package.path.."../../cimgui/generator/?.lua"
local cpp2ffi = require"cpp2ffi"
local read_data = cpp2ffi.read_data
local save_data = cpp2ffi.save_data
local copyfile = cpp2ffi.copyfile
local serializeTableF = cpp2ffi.serializeTableF

local func_header_generate = cpp2ffi.func_header_generate
local func_implementation = cpp2ffi.func_implementation


----------custom ImVector templates
local table_do_sorted = cpp2ffi.table_do_sorted
local function generate_templates(code,templates)
	--defined in cimgui
    --table.insert(code,"\n"..[[typedef struct ImVector{int Size;int Capacity;void* Data;} ImVector;]].."\n")
	table_do_sorted(templates , function (ttype, v)
		if ttype == "ImVector" then
			table_do_sorted(v, function(te,newte)
				table.insert(code,"typedef struct ImVector_"..newte.." {int Size;int Capacity;"..te.."* Data;} ImVector_"..newte..";\n")
			end)
		else
			print("unexpected ttype",ttype)
			error"unexpected ttype"
		end
	end)
end
--generate cimgui.cpp cimgui.h 
local function cimgui_generation(parser,name)

    local hstrfile = read_data("./"..name.."_template.h")

	local outpre,outpost = parser.structs_and_enums[1], parser.structs_and_enums[2]
	
	cpp2ffi.prtable(parser.templates)
	cpp2ffi.prtable(parser.typenames)
	local outtab = {}
    generate_templates(outtab, parser.templates)

	local cstructsstr = outpre..table.concat(outtab,"")..outpost 
	--vec3 and vec4 to G3Dvec3 for cimgui defined
	cstructsstr = cstructsstr:gsub("(%W)vec3(%W)","%1G3Dvec3%2")--("vec3","G3Dvec3")
	cstructsstr = cstructsstr:gsub("(%W)vec4(%W)","%1G3Dvec4%2")--("vec4","G3Dvec4")
	hstrfile = hstrfile:gsub([[#include "imgui_structs%.h"]],cstructsstr)
	
	--implementation before changing types (vec3 vec4) merge it in cimplot_template.cpp to cimplot.cpp
    local cimplem = func_implementation(parser)
    local hstrfilecpp = read_data("./"..name.."_template.cpp")
    hstrfilecpp = hstrfilecpp:gsub([[#include "auto_funcs%.cpp"]],cimplem)
    save_data("./output/"..name..".cpp",cimgui_header,hstrfilecpp)
	
	--generation of C++ headers
	local outtab = cpp2ffi.func_header_generate_structs(parser)
    table.insert(outtab, 1, "#ifndef CIMGUI_DEFINE_ENUMS_AND_STRUCTS\n")
    local outtabf = cpp2ffi.func_header_generate_funcs(parser)
	table.insert(outtabf,"#endif //CIMGUI_DEFINE_ENUMS_AND_STRUCTS\n")

	--generation of C headers (cimgui defined)
	--replace vec3 and vec4 with G3Dvec3 and G3Dvec4 in argsT and args
	for fun,defs in pairs(parser.defsT) do
		for i,def in ipairs(defs) do
			def.args = def.args:gsub("vec3([%W%*]*)","G3Dvec3%1")
			def.args = def.args:gsub("vec4([%W%*]*)","G3Dvec4%1")
			for j,arg in ipairs(def.argsT) do
				arg.type = arg.type:gsub("vec3([%W%*]*)","G3Dvec3%1")
				arg.type = arg.type:gsub("vec4([%W%*]*)","G3Dvec4%1")
			end
		end
	end
    local outtabfcimgui = cpp2ffi.func_header_generate_funcs(parser)
    table.insert(outtabfcimgui, 1, "#ifdef CIMGUI_DEFINE_ENUMS_AND_STRUCTS\n")
	table.insert(outtabfcimgui,"#endif //CIMGUI_DEFINE_ENUMS_AND_STRUCTS\n")

	local cfuncsstr = table.concat(outtab)..table.concat(outtabf)..table.concat(outtabfcimgui)
    cfuncsstr = cfuncsstr:gsub("\n+","\n") --several empty lines to one empty line
	
    hstrfile = hstrfile:gsub([[#include "auto_funcs%.h"]],cfuncsstr)
    save_data("./output/"..name..".h",cimgui_header,hstrfile)
    
    

end
--------------------------------------------------------
-----------------------------do it----------------------
--------------------------------------------------------
--get implot.h version--------------------------
--not working because there is no shuch info
--[=[
local pipe,err = io.open("../imGuIZMO.quat/imGuIZMO.quat/imGuIZMOquat.h","r")
if not pipe then
    error("could not open file:"..err)
end
local implot_version
while true do
    local line = pipe:read"*l"
    implot_version = line:match([[%s+v(.+)]])
    if implot_version then break end
end
pipe:close()
cimgui_header = cimgui_header:gsub("XXX",implot_version)
print("IMGUIZMOQUAT_VERSION",implot_version)
--]=]
--COMPILER = "g++"

-------------funtion for parsing implot headers
local function parseImGuiHeader(header,names)
	--prepare parser
	local parser = cpp2ffi.Parser()
	parser.getCname = function(stname,funcname,namespace)
		--local pre = (stname == "") and "ImPlot_" or stname.."_"
		local pre = (stname == "") and (namespace and (namespace=="ImGui" and "ig" or namespace.."_") or "ig") or stname.."_"
		return pre..funcname
	end
	parser.cname_overloads = cimgui_overloads
	parser.manuals = cimgui_manuals
	parser.UDTs = {"ImVec2","ImVec4","ImColor","ImRect"}
	
	local include_cmd = COMPILER=="cl" and [[ /I ]] or [[ -I ]]
	local extra_includes = include_cmd.." ../../cimgui ".." -x c++ " --force c++ compiling with gcc (Tp for cl?)
	print("try:",CPRE..extra_includes..header)
	local pipe,err = io.popen(CPRE..extra_includes..header,"r")

	if not pipe then
		error("could not execute COMPILER "..err)
	end
	
	local iterator = cpp2ffi.location
	
	for line,loca,loca2 in iterator(pipe,names,{},COMPILER) do
		parser:insert(line, loca)
	end

	pipe:close()
	return parser
end
--generation
print("------------------generation with "..COMPILER.."------------------------")
local modulename = "cimguizmo_quat"
local parser1 = parseImGuiHeader([[../imGuIZMO.quat/imGuIZMO.quat/imGuIZMOquat.h]],{[[imGuIZMOquat]]})
--save_data("headers.h",[[#include "../imGuIZMO.quat/imGuIZMO.quat/imGuIZMOquat.h" 
--	#include "../imGuIZMO.quat/imGuIZMO.quat/vgMath.h"]])
--local parser1 = parseImGuiHeader([[headers.h]],{[[imGuIZMOquat]],[[vgMath]]})
--os.remove("headers.h")
parser1:do_parse()


save_data("./output/overloads.txt",parser1.overloadstxt)
cimgui_generation(parser1,modulename)
save_data("./output/definitions.lua",serializeTableF(parser1.defsT))
local structs_and_enums_table = parser1:gen_structs_and_enums_table()
save_data("./output/structs_and_enums.lua",serializeTableF(structs_and_enums_table))
save_data("./output/typedefs_dict.lua",serializeTableF(parser1.typedefs_dict))

-------------------------------json saving
--avoid mixed tables (with string and integer keys)
local function json_prepare(defs)
    --delete signatures in function
    for k,def in pairs(defs) do
        for k2,v in pairs(def) do
            if type(k2)=="string" then
                def[k2] = nil
            end
        end
    end
    return defs
end
---[[
local json = require"json"
save_data("./output/definitions.json",json.encode(json_prepare(parser1.defsT)))
save_data("./output/structs_and_enums.json",json.encode(structs_and_enums_table))
save_data("./output/typedefs_dict.json",json.encode(parser1.typedefs_dict))
--]]
-------------------copy C files to repo root
copyfile("./output/"..modulename..".h", "../"..modulename..".h")
copyfile("./output/"..modulename..".cpp", "../"..modulename..".cpp")
print"all done!!"
